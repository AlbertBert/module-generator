#!/usr/bin/env node

const program = require('commander');
const chalk = require('chalk');
const readline = require('readline');
const fs = require('fs');
const path = require('path');
const child_process = require('child_process');
const error = chalk.bold.red;
const info = chalk.bold.blue;
const package = require('../package.json');
const version = package.version;
const basePath = process.cwd();
let dirValue;
let env;

program
  .version(version, '-v, --version')  // 设置命令的版本号，从package.json中读取，可以用-v或--version查询
  .usage('<dir> [options]')   // 设置命令的用法说明
  .arguments('<dir> [env]')   // 设置命名后面要接的参数，<>的参数表示必要参数,[]表示可选参数
  .action(function(dir, env) {  // action用于设置回调函数，其中回调函数的参数就是arguments中的参数
    console.log(dir, env);
    dirValue = dir;
    env = env;
  })
  .description('<dir> must be input')  // 设置命令的描述
  .parse(process.argv);                // 一般最后调用，用于解析process.argv参数
// 若没有输入要生成的项目名，则会有报错提示
if (typeof dirValue == 'undefined') {
  console.log(error('must be input dir name!\n'));
  console.log(error('example:\n'));
  console.log(error('generater dir\n'));
}

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})

main();

function main() {
  const curName = program.args.shift();
  const destinationPath = `${process.cwd()}/${curName}`;
  console.log(destinationPath);
  const desPath = path.join(basePath, dirValue);
  console.log(desPath);
  const step1 = readPromise(info('do you need test, continue? [y/N] '), (answer) => {
    program.test = true;
  });
  const step2 = readPromise(info('do you need demo, continue? [y/N] '), (answer) => {
    program.demo = true;
  })
  const step3 = readPromise(info('do you need .gitignore, continue? [y/N] '), (answer) => {
    program.gitignore = true;
  })
  const step4 = readPromise(info('do you need vue project, continue? [y/N] '), (answer) => {
    program.vue = true;
  })
  const step5 = readPromise(info('destination is not empty, continue? [y/N]'), (answer) => {
    child_process.exec(`rm -rf ${desPath}`, (err, stdout, stderr) => {
      if (err) {
        console.error(`exec error: ${error}`);
        return;
      }
    })
  })
  //const stepArray = [step1, step2, step3, step4];
  // stepArray.reduce((temp, value, index) => {
  //   return temp.then(() => {
  //     return value();
  //   });
  // }, Promise.resolve())
  var p = compose(step1, step2, step3, step4);
  console.log(p);
  p.then(() => {
    console.log(program.vue);
    fs.readdir(desPath, (err, files) => {
      if (err && err.code !== 'ENOENT') {
        throw err;
      }
      console.log(files);
      if (files && files.length) {
        compose(p, step5, close).then(() => {
          createFolds();
        })
      } else {
        console.log('111111');
        compose(p, close).then(() => {
          createFolds();
        })
      }
    })
  })
}

function close() {
  return rl.close();
}

// 将逐行读取等待用户输入封装成一个个的promise，以便依次执行
function readPromise(question, callback) {
  return function() {
    return new Promise((resolve) => {
      rl.question(question, (answer) => {
        if (/y|yes|ok/.test(answer)) {
          callback(answer);
        }
        resolve();
      })
    })
  }
}
// 使用数组的reduce方法使得多个promise能够依次串行执行
function compose(...args) {
  // 最终返回的结果执行完最后一个promise返回的结果
  // 使用一个Promise.resolve()作为最开始的temp
  return args.reduce((formerStep, laterStep) => {
    return formerStep.then(() => {
      return laterStep();
    })
  }, Promise.resolve())
}

function createFolds() {
  mkdirs(dirValue, (error) => {
    console.log(__dirname);     // 执行命令的文件所在的路径
    console.log(process.cwd())  // 执行命令时所在的路径
    // README.md
    copyTemplate('../template/md/README.md', 'README.md');
    // package.json
    copyTemplate('../template/package/package.json', 'package.json');
    // demo
    if (program.demo) {
      mkdirs(dirValue + '/demo', () => {
        copyTemplate('../template/html/index.html', 'demo/index.html');
      })
    }
    // src
    mkdirs(dirValue + '/src', () => {
      copyTemplate('../template/js/index.js', 'src/index.js');
      if (program.vue) {
        mkdirs(dirValue + '/src/app', () => {
          // 复制vue文件夹下的文件到src/app下，不包括vue文件夹自身
          const sourceDir = path.resolve(__dirname, '../template/vue/*');
          const destDir = basePath + '/' + dirValue + '/src/app';
          child_process.exec(`cp -rf ${sourceDir} ${destDir}`, (err, stdout, stderr) => {
            if (err) {
              console.error(`exec error: ${error}`);
              return;
            }
          })
        })
      }
    })
    // .gitignore
    if (program.gitignore) {
      copyTemplate('../template/gitignore/.gitignore', '.gitignore');
    }
    //.eslintrc
    copyTemplate('../template/eslint/.eslintrc', '.eslintrc')
    //.babelrc
    copyTemplate('../template/babel/.babelrc', '.babelrc')
  })
}

function emptyDir(path, cb) {
  fs.readdir(path, (err, files) => {
    if (err) {
      throw err;
    }

  })
}

function mkdirs(dirname, callback) {
  fs.stat(dirname, (err, stats) => {
    // stats=undefined说明目录不存在
    if (stats == undefined) {
      mkdirs(path.dirname(dirname), () => {
        fs.mkdir(dirname, callback);
      })
    } else {
      callback();
    }
  })
}

function copyTemplate(from, to) {
  fs.createReadStream(path.resolve(__dirname, from))
    .pipe(fs.createWriteStream(path.join(basePath, dirValue, to)));
}
